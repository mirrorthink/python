{"title": "阿里盒马、腾讯小程序团队 —— 小菜鸡自闭の面经（等HRing...） ... ", "author": "Rolan", "pub_time": "2020-3-27 00:42", "content": "俺这只小菜鸡:chicken:终于也快迎来曙光了！:grinning:俺现在是一名大三学生，渴望能获得一份大厂的实习机会呜呜呜，所以不自量力的投了一下阿里跟腾讯。阿里是提前批就开始面了的。很多部门都面了一下下，面了啥也忘了哈哈哈哈。也多亏了提前批，让俺知道哪些地方还需要再补补。阿里这边最终选择了盒马，盒马的面试官都好好，好和蔼，给了好多建议，没有因为我菜就嫌弃我呜呜呜，太感动了。而且！看到这张“ 屁股脸 ”难道不想加入换一套限量公仔/手办吗！个人の想法我觉得面试更像是一次学习的机会，可以查漏补缺，之后自己深入学习更多的东西我还是觉得大厂面试，还是得有一个自己熟悉的、参与度高的项目来展开，因为还是很多面试官会选择问问项目经历来了解我们。不会就是不会哈哈哈哈，老实承认就好，之后自己下去再找找资料补一补就好！不必沉浸在悲伤之中面试完之后，如果有问题，尽量积极主动的去寻找面试官请教，不要觉得不好意思或者说不敢这样子，我觉得就算即便是挂了也好，也可以请教一下学到更多的东东，不至于一场面试下来颗粒无收阿里の盒马初面初面是聊得最久的一次了，一个多小时了吧，不过初面的面试官真的很让人感动一直在鼓励我，“好啊好啊”，“没关系没关系”，啊太棒了，给俺这个小菜鸡很多信心hhhh输入url到页面展示浏览器存储如何实现继承跨域，常用哪个，解释一下缓存重绘回流性能优化React优势React生命周期React最佳实践React新特性如果列表组件要新增一些内容，例如标题，简介等，你会怎么对代码进行修改（容器组件 -> 展示组件）csrf 和 xssflex判断是否为数组typeof arr === 'object'浏览器事件循环，node事件循环事件委托webpack流程，插件koa源码koa洋葱模型mobx原理首屏优化async/await Promise盒模型babel原理Taro原理一面一面俺就放放笔试题还有俺自己做的情况吧哈哈哈哈，一面的面试官跟俺说拓扑排序，俺才知道原来还有这种东西（流泪...笔试题目给定一个链表，判断链表中是否有环，比如下图这种即为有环链表。加分项：使用空间复杂度 O(1) 实现分析一个项目的依赖结构，并按依赖优先级排序。 已知一个项目的依赖结构，期望在前端通过 loader 的方式异步加载相关的组件，而我们期望依赖在加载的过程中：每一个依赖被加载后都会被立刻执行，那么如果要争取加载一个依赖，则其子依赖都应该优先被加载每一个依赖不希望在钱多出现冗余的情况，若依赖出现多版本的情况，则默认使用更新的版本，比如已知项目依赖结构为（其中 @ 后面的为依赖版本号）：ProjectA\r\n- a@0.1.0\r\n    - d@0.2.0\r\n    - c@0.1.0\r\n- b@0.1.1\r\n    - e@0.1.2\r\n    - c@0.1.2\r\n- c@0.2.0\r\n复制代码则其中一种输出的依赖优先级排序为：['d@0.2.0', 'c@0.2.0', 'a@0.1.0', 'e@0.1.2', 'b@0.1.1']输出分析： 为了让 a 加载后可以争取执行，则必须先加载 d 和 c，b 的加载同理，又因为在整个依赖关系下，c 的最新版本为 0.2.0 于是有了如上的输出结果。请用 React 实现一个搜索框组件，功能包括：输入文本字数限制可配置输入文本约束，比如仅限输入数字用户输入时可支持关键字搜索，并出现下拉框展示相关项俺的答案第一题leetcode原题来的，环形链表好像是，可以用快慢指针或者简单的集合const cycle1 = function (node) {\r\n  let set = new Set()\r\n  while (node) {\r\n    if (set.has(node))\r\n      return true\r\n    else\r\n      set.add(node)\r\n    node = node.next\r\n  }\r\n  return false\r\n};\r\n\r\n\r\n\r\nconst cycle2 = function (node) {\r\n  let start = node\r\n  let end = node.next\r\n  while (start !== end) {\r\n    // 没有环就null\r\n    if (end === null || end.next === null) return false\r\n    start = start.next\r\n    end = end.next.next\r\n  }\r\n  return true\r\n}\r\n复制代码第二题的话我拿到题目第一个想到的就是DFS来寻找那些依赖，然后最后再对依赖这些进行版本比较（其实应该用集合、还有拓扑排序来优化）function update(npmList) {\r\n  let versions = {}\r\n  let res = []\r\n\r\n  // 比较版本号\r\n  function cmp(a, b) {\r\n    const versionA = getVersion(a).split('.')\r\n    const versionB = getVersion(b).split('.')\r\n    for (let index = 0; index < 3; index++) {\r\n      if (versionA[index] > versionB[index]) return a\r\n      else if (versionA[index] === versionB[index]) continue\r\n      else return b\r\n    }\r\n    return a\r\n  }\r\n\r\n  // 获得版本号\r\n  function getVersion(str) {\r\n    return str.substr(str.indexOf('@') + 1)\r\n  }\r\n\r\n  function dfs(npmList) {\r\n    if (npmList.length === 0) return\r\n\r\n    npmList.forEach((npm) => {\r\n      const { name, deps = [] } = npm\r\n      // 先遍历他们的依赖\r\n      dfs(deps)\r\n      let key = name.substr(0, name.indexOf('@'))\r\n      // 如果依赖不存在则添加，若已存在，则取最新版\r\n      if (!versions[key]) {\r\n        versions[key] = name\r\n      } else {\r\n        versions[key] = cmp(versions[key], name)\r\n      }\r\n      // 添加进最后的加载列表\r\n      res.push(key)\r\n    })\r\n    return\r\n  }\r\n  dfs(npmList)\r\n  // 去除重复项，然后将包名转换为依赖名，eg: a -> a@0.1.0\r\n  return [...new Set(res)].map(key => versions[key])\r\n}\r\n复制代码第三题的话，我粗略写了一下噗，写的也不是很好，用React整的// 第三题React部分第三题React部分第三题React部分第三题React部分第三题React部分\r\n\r\nimport React, { Component } from 'react';\r\nimport './input.css'\r\n\r\nfunction debounce(fn, delay = 500) {\r\n  let timeout = null\r\n  return function (e, ...args) {\r\n    e.persist && e.persist()\r\n    timeout && clearTimeout(timeout)\r\n    timeout = setTimeout(() => {\r\n      fn.call(this, e, ...args)\r\n    }, delay)\r\n  }\r\n}\r\n\r\nclass Tips extends Component {\r\n  render() {\r\n    const { tipsList } = this.props\r\n    return tipsList && tipsList.length !== 0 ? (\r\n      <div className=\"tips__container\">\r\n        {tipsList.map((item, index) => {\r\n          return (\r\n            <a href=\"#\" key={index} className=\"link\">{item}</a>\r\n          )\r\n        })}\r\n      </div>\r\n    ) : <div></div>\r\n  }\r\n}\r\n\r\nexport default class Input extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      keyWords: [\r\n        '前端工程师1', '前端高级开发1', '后端工程师1', '测试开发1', '项目主管1', 'dress', 'Recent', '123456', 'awdad1'\r\n      ],\r\n      inputValue: '',\r\n      inputType: 'text',\r\n      inputMaxLen: 20,\r\n      wordsList: []\r\n    }\r\n    this.handleInput = debounce(this.handleInput, 200)\r\n    this.handleMaxLenChange = debounce(this.handleMaxLenChange, 400)\r\n  }\r\n\r\n  handleInput = (e) => {\r\n    const { target: { value } } = e\r\n    const { keyWords } = this.state\r\n    const tipsList = !value\r\n      ? []\r\n      : keyWords.filter(item => {\r\n        const res = item.search(new RegExp(value, 'i'))\r\n        return res !== -1\r\n      })\r\n    this.setState({\r\n      inputValue: value,\r\n      tipsList\r\n    })\r\n  }\r\n\r\n  handleTypeClick = (e) => {\r\n    const { target: { name } } = e\r\n    this.setState({ inputType: name })\r\n  }\r\n\r\n  handleMaxLenChange = (e) => {\r\n    const { target: { value } } = e\r\n    const { inputValue } = this.state\r\n    const newInputValue = inputValue.substr(0, +value)\r\n    // 如果设置最大长度小于现在关键词的长度，则截取一下\r\n    this.input.value = newInputValue\r\n    this.setState({ inputMaxLen: value, inputValue: newInputValue })\r\n  }\r\n\r\n  render() {\r\n    const { tipsList, inputType, inputMaxLen } = this.state\r\n    return (\r\n      <div className=\"container\">\r\n        <div className=\"control__container\" onClick={this.handleTypeClick}>\r\n          <button name=\"text\">文本</button>\r\n          <button name=\"number\">数字</button>\r\n          <span>最大长度: </span>\r\n          <input type=\"number\" placeholder=\"默认: 20\" onInput={this.handleMaxLenChange} />\r\n        </div>\r\n        <div className=\"input__container\">\r\n          <div className=\"input__wrap\">\r\n            <input\r\n              ref={input => this.input = input}\r\n              placeholder=\"请输入关键词\"\r\n              type={inputType}\r\n              maxLength={inputMaxLen}\r\n              onInput={this.handleInput} />\r\n            <button>搜索</button>\r\n          </div>\r\n          <Tips tipsList={tipsList} />\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n复制代码// 第三题CSS部分第三题CSS部分第三题CSS部分第三题CSS部分第三题CSS部分第三题CSS部分\r\n\r\n\r\n.container {\r\n  width: 600px;\r\n  height: 400px;\r\n  margin: 0 auto;\r\n  padding: 30px;\r\n  background: #fff;\r\n}\r\n\r\n.input__container {\r\n  margin-top: 30px;\r\n}\r\n\r\n.input__wrap {\r\n  display: flex;\r\n  align-items: center;\r\n}\r\n\r\n.input__wrap input {\r\n  box-sizing: border-box;\r\n  width: 85%;\r\n  height: 50px;\r\n  padding: 0 10px;\r\n  border: #666 1px solid;\r\n  border-right: 0;\r\n  outline: none;\r\n}\r\n\r\n.input__wrap button {\r\n  cursor: pointer;\r\n  box-sizing: border-box;\r\n  width: 15%;\r\n  height: 50px;\r\n  color: #fff;\r\n  font-size: 20px;\r\n  border: none;\r\n  border: #666 1px solid;\r\n  outline: none;\r\n  background: #1890ff;\r\n}\r\n\r\n.control__container {\r\n  display: flex;\r\n  align-items: center;\r\n}\r\n\r\n.control__container button {\r\n  cursor: pointer;\r\n  width: 50px;\r\n  height: 30px;\r\n  margin-right: 10px;\r\n  color: #fff;\r\n  outline: none;\r\n  border: #333 1px solid;\r\n  border-radius: 8px;\r\n  background: #1890ff;\r\n}\r\n\r\n.control__container span {\r\n  margin-left: auto;\r\n  margin-right: 10px;\r\n  color: #666;\r\n  font-size: 14px;\r\n}\r\n\r\n.tips__container {\r\n  overflow-y: scroll;\r\n  max-height: 200px;\r\n  border: #333 1px solid;\r\n  border-top: 0;\r\n}\r\n\r\n.tips__container .link {\r\n  display: block;\r\n  height: 30px;\r\n  padding: 5px 10px;\r\n  color: #666;\r\n  line-height: 30px;\r\n  text-decoration: none;\r\n}\r\n\r\n.tips__container .link:hover {\r\n  color: #fff;\r\n  background: #666;\r\n}\r\n\r\ninput::-webkit-outer-spin-button,\r\ninput::-webkit-inner-spin-button {\r\n  display: none;\r\n}\r\n复制代码二面二面主要是结合项目来问的，抓住一个功能发散开来，例如我项目的聊天室的功能，吓得我好慌好慌hhh，不过面试官人很好一直引导我，特别是那些场景题，引导我去思考，啊，太感动了！！！项目の各种东东聊天私聊怎么做聊天记录未读消息怎么做聊天离线信息处理session会话管理如何实现（用户登录后，打开新标签页输入url访问资源）访问资源权限控制事件队列题websocket如何连接做题系统组件的设计与拓展（拓展更多类型的题目，如何设计组件）用户鉴权系统设计为什么密码表跟用户信息表分开放数据库表的设计三面这一面也是结合项目来问的。啊，三面的面试官真的太好了，期初我的小项目没什么难点（我都以为凉透透了呜呜呜），然后面试官给了提了几个建议，让我多去深入思考思考，面试完之后去找他请教问题，也一直很有耐心给我指导指导，啊，太棒了吧项目の各种东东飞猪为什么挂了项目难点小程序登录怎么做的封装了什么组件建议：在线阅卷、批注、修改错别字等（canvas绘制）建议：实时监控每个同学的进度（选择答案后之后教师端更新/摄像头监控）a与b聊天，将他们的记录，多选，然后合并发给c，如何设计除了编译成小程序，有试过app吗四面四面应该是总监面，还是得感谢三面的面试官给我提的建议，之后做出来之后，发现这个东东可以作为项目的一个难点来吹哈哈哈！四面主要还是围绕项目来问，我个人觉得关注的更是自己的思维、对技术的认识、对自己未来的发展规划等宏观的内容就是这个小功能，canvas实现作业批注等功能项目难点（canvas绘制公式websocket实现，聊天功能的实现（心跳检测，断线重连项目の细节聊天信息的一致性，时序性目标、具体想通过实习学到什么技术规划，之后学些什么五面五面是交叉面，心惊胆跳呜呜呜，希望不要挂我...五面问的大多是基础方面的内容，不过也是结合项目来问的，这一面面试官主要关注的是 性能 方面的内容，例如数据埋点啊、页面加载时间、接口响应时间等一系列关于性能方面的问题，他希望的是数据量化的一个东东，具体的实现，达成了什么目标等项目做了那些事情小程序运行池小程序和H5的区别缓存存在哪（强缓存、协商缓存分别通过什么字段保存React与Vue的区别React的优势Taro编译的机制Taro支持的端有哪些node的机制、优势项目的难点，如何解决，遇到的问题如何监控性能尝试做了哪些性能上的优化收集用户信息？数据埋点？性能指标？量化指标？资源大小，加载速度，页面渲染时间，接口访问时间如何优化node后台的接口（sql优化，表结构重写使用什么服务器，部署在什么操作系统上多人同时访问接口测试过吗？最高承载多少webpack如何减小资源打包大小擅长什么你的优势是什么目标？规划？腾讯の小程序一面一面是笔试 + 面试，俺也放放题目跟俺的答案吧！笔试题目实现⼀个函数 reverse(a, n) ，反转⼀个含有 n 个整数的数组 a（直接在数组a上操作，元素交换次数 尽可能少，不能使⽤js Array 类内置属性和⽅法）。实现⼀个函数 countLongest(tree) ，输⼊⼀棵⼆叉树，返回⼆叉树中距离最⻓的两个叶⼦节点之间 的距离。var x = [0, 1, 2, 3]\r\nreverse(x, 4) // x = [3, 2, 1, 0]\r\nvar y = [1, 2, 3, 4, 1]\r\nreverse(y, 5) // y = [1, 4, 3, 2, 1]\r\nvar tree1 = {\r\n  value: 1,\r\n  left: {\r\n    value: 2\r\n  },\r\n  right: {\r\n    value: 3\r\n  }\r\n}\r\ncountLongest(tree1) // 2\r\nvar tree2 = {\r\n  value: 1,\r\n  left: {\r\n    value: 2,\r\n    left: {\r\n      value: 3,\r\n      left: {\r\n        value: 6\r\n      }\r\n    },\r\n    right: {\r\n      value: 4\r\n    }\r\n  },\r\n  right: {\r\n    value: 5\r\n  }\r\n}\r\ncountLongest(tree2) // 4\r\n复制代码在前端开发中，通常会把多个js⽂件合并成⼀个⽂件，以减少⽹络请求次数，达到优化加载速度的⽬ 的，但是当⽂件之间存在依赖关系时，对js合并的顺序，会有⼀定的要求，⽐如 A.js 依赖了 B.js，那打 包后的⽂件，B.js 需要排在 A.js 的前⾯。 实现⼀个函数 resolve(tree) ，根据js的依赖关系树 tree，输出合理的打包顺序的数组（结果可能不 唯⼀，输出其中⼀种即可）。样例var tree1 = {\r\n  name: 'main.js',\r\n  require: [{\r\n    name: 'A.js'\r\n  }, {\r\n    name: 'B.js'\r\n  }]\r\n}\r\nresolve(tree1) // ['A.js', 'B.js', 'main.js']\r\nvar tree2 = {\r\n  name: 'page.js',\r\n  require: [{\r\n    name: 'A.js',\r\n    require: [{\r\n      name: 'B.js',\r\n      require: [{\r\n        name: 'C.js'\r\n      }]\r\n    }]\r\n  }, {\r\n    name: 'D.js',\r\n    require: [{\r\n      name: 'C.js'\r\n    }, {\r\n      name: 'E.js'\r\n    }]\r\n  }]\r\n}\r\nresolve(tree2) // ['C.js', 'E.js', 'D.js', 'B.js', 'A.js', 'page.js']\r\n复制代码给定⼀个整数数组 a，实现⼀个函数 countMax(a) ，计算出从 a 中选择出多个不相邻元素组成最⼤的 和是多少。样例var x = [1, 4, 5, 3]\r\ncountMax(x) // 7\r\nvar y = [3, 12, 6, 2, 4]\r\ncountMax(y) // 16\r\n复制代码俺的答案就是简单的倒置hhhfunction reverse(arr) {\r\n  let len = arr.length\r\n  for (let start = 0; start < Math.floor(len / 2); start++) {\r\n    let end = len - start - 1;\r\n    [arr[start], arr[end]] = [arr[end], arr[start]]\r\n  }\r\n  return arr\r\n}\r\n复制代码这题是leetcode原题好像，就算算深度function countLongest(tree) {\r\n  if (!tree) return 0\r\n  let res = 0\r\n\r\n  function dfs(node) {\r\n    if (!node) return 0\r\n    const leftMax = dfs(node.left)\r\n    const rightMax = dfs(node.right)\r\n    res = Math.max(leftMax + rightMax, res)\r\n    return Math.max(leftMax, rightMax) + 1\r\n  }\r\n  dfs(tree)\r\n  return res\r\n}\r\n\r\nconsole.log(countLongest({\r\n  value: 1,\r\n  left: {\r\n    value: 2\r\n  },\r\n  right: {\r\n    value: 3\r\n  }\r\n}))\r\nconsole.log(countLongest({\r\n  value: 1,\r\n  left: {\r\n    value: 2,\r\n    left: {\r\n      value: 3,\r\n      left: {\r\n        value: 6\r\n      }\r\n    },\r\n    right: {\r\n      value: 4\r\n    }\r\n  },\r\n  right: {\r\n    value: 5\r\n  }\r\n}))\r\n复制代码第三题是不是很眼熟哈哈哈，跟盒马一面的笔试题好像（其实我发现很多面试笔试题都有这相关的影子）还是DFS来找function resolve(npmList) {\r\n  const res = []\r\n\r\n  function dfs(npmList) {\r\n    if (npmList.length === 0) return\r\n\r\n    npmList.forEach((npm) => {\r\n      const { name, require = [] } = npm\r\n      dfs(require)\r\n      !res.includes(name) && res.push(name)\r\n    })\r\n    return\r\n  }\r\n  dfs(npmList)\r\n  return res\r\n}\r\n\r\n\r\nconsole.log(resolve([{\r\n  name: 'page.js',\r\n  require: [{\r\n    name: 'A.js',\r\n    require: [{\r\n      name: 'B.js',\r\n      require: [{\r\n        name: 'C.js'\r\n      }]\r\n    }]\r\n  }, {\r\n    name: 'D.js',\r\n    require: [{\r\n      name: 'C.js'\r\n    }, {\r\n      name: 'E.js'\r\n    }]\r\n  }]\r\n}]))\r\n复制代码用动态规划来找function countMax2(arr) {\r\n  const len = arr.length\r\n  const dp = new Array(len).fill(0);\r\n  dp[0] = arr[0]\r\n  dp[1] = arr[1]\r\n  dp[2] = arr[0] + arr[2]\r\n  // [1, 4, 7, 0]\r\n\r\n  // [3, 12, 9, ...], \r\n  // [3, 12, 9, 14, ...],\r\n  for (let i = 3; i < len; i++) {\r\n    dp[i] = arr[i] + Math.max(dp[i - 2], dp[i - 3])\r\n  }\r\n  return dp[len - 1]\r\n}\r\n\r\nconsole.log(countMax2([1, 4, 5, 3]))\r\nconsole.log(countMax2([3, 12, 6, 2, 4]))\r\n// console.log(countMax2([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7]))\r\n复制代码面试内容项目为什么用token不用cookie跨域（前端跟前端的跨域，iframe之间）xssReact与Vue的对比Taro与其他多端框架主要还是项目发散如何实现轮播图二面二面基本都是一些基础吧，但是就有些地方会深入去挖这样子https原理，握手过程(何时对称/非对称，谁先谁后，为什么这样)常见的优化webp格式优化了多少缓存以键值形式存在浏览器，键是什么，值是什么设计一个缓存策略，（hash值）React的keyReact与Vue的区别Taro与小程序官方框架的区别小程序运行池React列表key固定，顺序调换会渲染吗（不会）如何判断性能瓶颈项目の各种东东三面三面感觉还不够二面难，问的比较常见吧应该说，然后也是问问项目这样子算法：判断数组中是否存在两个数相加等于目标值，给出多种思路与时间空间复杂度（暴力循环，排序后循环剪枝，动态规划）es6的class如何实现私有变量（symbol + 闭包）如何进行性能监控常见的性能优化方法内存泄露如何发现，如何解决垃圾回收机制跨域（cors + jsonp + 其他不常见的跨域方法）浏览器缓存实现深拷贝，深拷贝的用途xss、csrfcookie与token的工作原理，区别，如何设计http1.1、http2.0http无状态websocket是什么协议，如何连接websocket有什么优势，对比轮训呢事件循环setTimeout是否准时，如果不是则应该提前还是延迟webpack流程常见的http状态码babel原理、taro原理map中的键值会不会被回收（weakMap，weakSet等）项目....难点、设计、收获平时如何学习"}
{"title": "微信小程序开发中的http请求总结 ", "author": "Rolan", "pub_time": "2020-3-24 00:41", "content": "在微信小程序进行网络通信，只能和指定的域名进行通信，微信小程序包括四种类型的网络请求。普通HTTPS请求(wx.request)上传文件(wx.uploadFile)下载文件(wx.downloadFile)WebSocket通信(wx.connectSocket)这里以介绍 wx.request , wx.uploadFile , wx.dowloadFile 三种网络请求为主设置域名要微信小程序进行网络通信，必须先设置域名，不然会出现错误:URL 域名不合法，请在 mp 后台配置后重试需要在微信公众平台的小程序中设置域名。在微信小程序的 设置界面 可以看到设置选项：选择 开发设置 ：开发设置可以看到服务器设置:服务器设置在这里可以设置对应四种网络访问的域名，每一种类型的网络请求需要设置一个域名，注意如果在这里设置域名为 https://example.com/api/ ,那么 https://example.com/api 是无法调用的，必须加上后面 / 。http请求使用 wx.request 可以发起一个http请求，一个微信小程序被限制为同时只有5个网络请求。function queryRequest(data){    \r\n    wx.request({\r\n        url:\"https://example.com/api/\",\r\n        data:data,\r\n        header:{\r\n           // \"Content-Type\":\"application/json\"\r\n        },\r\n        success:function(res){\r\n            console.log(res.data)\r\n        },\r\n        fail:function(err){\r\n            console.log(err)\r\n        }\r\n\r\n    })\r\n\r\n}\r\n上面的代码会发送一个http get请求，然后打印出返回的结果。其中的参数也比较容易理解。url  服务器的url地址data  请求的参数可以采用String  data:\"xxx=xxx&xxx=xxx\" 的形式或者Object  data:{\"userId\":1} 的形式header  设置请求的headersuccess  接口成功的回调fail  接口失败的回调另外还有两个参数没有在代码里:method\r\ncomplete\r\n上传文件上传文件的api为 wx.uploadFile ，该api会发起一个 http post 请求，其中的 Content-type为 multipart/form-data 。服务器端需要按照该 Content-type 类型接收文件,示例代码：function uploadFile(file,data) {\r\n    wx.uploadFile({\r\n        url: 'http://example.com/upload',\r\n        filePath: file,\r\n        name: 'file',\r\n        formData:data,\r\n        success:function(res){\r\n            console.log(res.data)\r\n        },\r\n        fail:function(err){\r\n            console.log(err)\r\n        }\r\n\r\n    })\r\n\r\n}\r\n其中的 url ， header ， success ， fail 以及 complete 和普通的http请求是一样的。这里有区别的参数是:name 文件对应的key，服务器端需要通过 name 参数获取文件formData  http请求中可以使用的其他参数下载文件下载文件的api为 wx.downloadFile ,该api会发起一个http get请求，并在下载成功之后返回文件的临时路径，示例代码：function downloadFile(url,typ,success){\r\n    wx.downloadFile({\r\n        url:url,\r\n        type:typ,\r\n        success:function(res){\r\n            if(success){\r\n                success(res.tempFilePath)\r\n            }\r\n        },\r\n        fail:function(err){\r\n            console.log(err)\r\n        }\r\n    })\r\n}\r\n其中的 url , header , fail , complete 和 wx.uploadFile 的参数使用是一致的，其中有区别的参数是:type :下载资源的类型，用于客户端自动识别，可以使用的参数 image/audio/videosuccess ：下载成功之后的回调，以 tempFilePath 的参数返回文件的临时目录： res={tempFilePath:'文件路径'} 下载成功后的是临时文件，只会在程序本次运行期间可以使用，如果需要持久的保存，需要调用方法 wx.saveFile 主动持久化文件，实例代码:function svaeFile(tempFile,success){\r\n  wx.saveFile({\r\n      tempFilePath:tempFile,\r\n      success:function(res){\r\n          var svaedFile=res.savedFilePath\r\n          if(success){\r\n              success(svaeFile)\r\n          }\r\n      }\r\n  })\r\n}使用 wx.saveFile 保存临时文件到本地，提供给小程序下次启动时使用，其中的参数：tempFilePath 需要被保存文件的路径success  保存成功的回调，返回保存成功的路径，使用 res.savedFilePath 可以获取保存成功的路径fail  失败的回调complete 结束的回调超时的设置app.js中调整设置：\r\n\r\n\"networkTimeout\":{\r\n   \"request\": 10000,\r\n   \"connectSocket\": 10000,\r\n   \"uploadFile\": 10000,\r\n   \"downloadFile\": 10000\r\n}\r\n这里设置的超时时间对应着四种类型的网络请求。"}
{"title": "微信小程序直播有何魅力？多套组合带你开启带货新模式！ ", "author": "Rolan", "pub_time": "2020-3-25 00:01", "content": "导购、设计、CEO齐上阵，微信小程序直播到底有何魅力？淘宝321直播购物节正在火热进行中，2020年刚过去不到四分之一，直播已经呈现井喷的架势，三八节过后，平台纷纷发布战报，作为刚入局直播不久的微信小程序直播，也取得了亮眼的成绩。完美日记、罗莱家纺、悦诗风吟、野兽派等近千个品牌小程序同时参与，导购、设计、CEO齐上阵，罗莱家纺总裁亲自直播，6小时交易额超1000万元。忽然之间出现的小程序直播，是腾讯直播吗？跟看点直播有什么区别？其实我们以往所说的腾讯直播，应该叫做腾讯看点直播，是由腾讯PCG（平台与内容事业部，QQ、腾讯视频的事业群）推出的直播产品，包括两个部分， 商家开播需要注册使用的“腾讯直播APP”以及用户观看直播的小程序“看点直播”。想在腾讯看点直播实现边看边买，有2种方法：1、把商城建在腾讯直播里。商家需要入驻腾讯直播的合作服务商，将店铺同步绑定腾讯直播账号，并关联商品。2、跳转向自己的小程序，商家可以添加微信好友“腾讯直播助手”申请绑定自己的店铺小程序，通过跳转店铺小程序的方式实现直播带货。方式1对于已经有了小程序的商家而言显然比较多余，并且等同于将用户数据交给了平台。方式2则产生了跳出，多一步跳转过程可能增加流失、降低转化率，同时小程序跳转次数存在限制，直播排期需提前申请，也为方式2带来了诸多不便。而小程序直播是由微信团队基于小程序于今年2月份开始公测的新路径， 商家在自有的小程序开发接入直播组件即可实现直播 ，商家在小程序这一“私域”内实现用户互动与商品销售闭环。腾讯看点直播与小程序直播各方面对比另外，我们整理了腾讯官方直播体系、淘宝直播、抖音快手，还有很多基于微信生态产生的直播平台，比如：有赞的爱逛直播，有播、特抱抱等。全网直播平台盘点局部图（原图点击文末下载）今天我们重点来说说小程序直播。01｜邀请制，克制开放据了解，目前小程序直播公测采用邀请制，符合以下条件的电商平台、自营商家，就有可能被邀请。满足小程序18个开放类目（包括：电商平台、商家自营-百货、食品、初级食用农产品、酒/盐、图书报刊/音像/影视/游戏/动漫、汽车/其他交通工具的配件、服装/鞋/箱包、玩具/母婴用品(不含食品)、家电/数码/手机、美妆/洗护、珠宝/饰品/眼镜/钟表、运动/户外/乐器、鲜花/园艺/工艺品、家居/家饰/家纺、汽车内饰/外饰、办公/文具、机械/电子器件）；主体下小程序近半年没有严重违规；小程序近90天存在支付行为；主体下公众号累计粉丝数大于100；主体下小程序连续7日日活跃用户数大于100；主体在微信生态内近一年广告投放实际消耗金额大于1w。2019年，小程序日活跃用户超过3亿，累计创造8000多亿交易额，小程序已经成为微信生态内又一大流量聚集地，在当下各大平台都积极部署直播的情况下，小程序发展直播也可以说是顺应时代的一步，但是 从邀请制来看，微信团队发展小程序直播还是比较克制的 ，以目前三八节这一大型节点的试水来看，商家取得的成绩是不错的。02｜小程序直播能干什么？接到邀请的商家可在小程序后台“功能-直播”申请直播能力，通过官方审核之后根据文档开发，即可在自有小程序上进行直播，官方称目前最快一天即可开发完成，运营20分钟即可上手。现已具备商品展示、点赞、抽奖、评论、优惠券派发等能力， 用户在直播间可以完成从观看到购买的全部流程，不用跳转至其他平台。还可以分享直播间给微信好友或微信群。抽奖可直接调用微信地址目前小程序内每个直播间直播不能超过12小时，同一个小程序可以支持50直播间同时直播，一天的直播上限也是50场。已入库的商品上限是2000，每天最多提交审核500件商品。从数量上来看，目前小程序规模仍不大，对于数量众多的连锁商超来说不是很友好，这可能是考虑到微信生态对于大批直播流量的承载能力，官方也表示未来会逐步增加展示空间。据了解，之后还将推出：小程序订阅功能，这类似微信公众号的做法，用户只需订阅一次，即可接收后期的开播通知；官方优惠券；快速回看，现阶段商家可自行开发回看功能；在微信内获得更多展示空间。03 ｜ 多套组合开启带货新模式小程序直播是完完全全的私域流量运营，如何巧妙运用这一功能，商家需要一些组合打法，现在我们发现还有更多玩法正在被运用。搜一搜+小程序直播前几天天虹尝试了一种新玩法——“ 搜索直达直播 ”。用户在微信搜索“天虹”就可以直接到达直播现场。半公域的搜一搜引流至小程序直播私域沉淀，3月14日，天虹联动斐乐品牌专场直播，搜一搜品牌官方区当天有50.15%的点击率；活动当天斐乐天虹全国线上销售超200万。搜一搜页面企业微信+小程序直播还是以天虹为例，他们利用企业微信，用户线上线下添加导购，过去一年，天虹的导购连接了500多万顾客。利用企业微信积累、维护客户，已经积累了一大批私域流量，如今小程序直播开通，从流量积累——流量变现，实现业务闭环。天虹导购朋友圈商家有自己的小程序才能入局小程序直播，这对没有小程序的商家不太友好，但是微信生态的玩法很多，等待商家们去探索，随着微信官方功能的不断完善，小程序直播究竟能发挥多大的能量，值得我们期待！-END-"}
{"title": "使用gulp构建微信小程序开发工作流 ", "author": "Rolan", "pub_time": "2020-3-25 00:36", "content": "web开发基本上都是基于webpack或者其他的构建工具来进行开发，大大节约了开发者的时间。目前的微信小程序开发也有很多开源的框架可供选择，但是如果使用原生开发模式，虽然可以完美使用小程序原生的新特性和功能，但是工作流角度上却十分简陋。19年末的时候公司要开发一个新的小程序，组里面的大佬同事提议使用gulp来构建下原生开发模式的工作流。一是为了摆脱简陋的工作流模式以节约开发时间，二是也是把技术用到刀刃上。在大佬的指导开发下，这个工作便进行了。总体来说这个工作并不难，增益可能也没有那么大，但是还是收获了很多。项目地址： gulp-mp工作流改进我们把开发目录设置在 src ，输出目录设置在 dist ，定义开发与输出路径。文件复制微信小程序的page目录通常包含 wxml , json , wxss 和 js 文件，与原生开发模式不同的是我们使用 sass 预处理器来写样式，其他的文件保持原样不同。因此，对于 wxml , json , js 文件来说，仅仅需要copy就行。因为在项目中已经配置了 eslint+prettier 来进行语法检查和代码美化，因此不需要在工作流的js代码进行规范检查。如果没有配置，可以安装 gulp-eslint 执行eslint规范检查。const srcPath = \"./src/**\";\r\nconst distPath = \"./dist/\";\r\nconst wxmlFiles = [`${srcPath}/*.wxml`];\r\nconst jsFiles = [`${srcPath}/*.js`, `!${srcPath}/env/*.js`];\r\nconst jsonFiles = [`${srcPath}/*.json`];\r\n\r\n// copy wxml\r\nconst wxml = () => {\r\n  return gulp\r\n    .src(wxmlFiles, { since: gulp.lastRun(wxml) })\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(wxml);\r\n\r\n// 其他copy流类似\r\n...\r\n复制代码sass处理上面我们提到使用 sass 预处理来编写样式，在输出的时候我们需要把 scss 样式转换成 wxss， wxss 就是普通的 css 样式。这里，我们使用 gulp-sass 插件转换scss样式。但是，需要注意的是在 scss 文件中，我们可能会import相关样式，可能是公共样式也可能是varibale和minxin。经过测试发现，当import公共样式，会把这个公共样式打包进当前页面。我们知道小程序的包是有大小限制的，如果在引入公共样式的时候还打包到当前页面，无疑是消耗掉了不必要的内存。所以，针对公共样式的import处理为，不交给sass处理，保留import并把后缀的.scss改成.wxss。当import的是变量和mixin时，我们需要保留对其的sass处理，因此新建独立的目录存放以便识别。在这一场景下，变量和mixin的文件不再递归处理。//存放variable和mixin的sass文件在被引用时直接导入，不引入dist目录中\r\nconst DIRECTIMPORT = [\"/scss/\", \"/font/\"];\r\nconst sassFiles = [`${srcPath}/*.{scss, wxss}`];\r\n\r\nconst wxss = () => {\r\n  return gulp\r\n    .src([...sassFiles, ...DIRECTIMPORT.map(item => `!${srcPath}/${item}/*`)], {\r\n      since: gulp.lastRun(wxss)\r\n    })\r\n    .pipe(plumber({ errorHandler: onError }))\r\n    .pipe(\r\n      tap(file => {\r\n        const filePath = path.dirname(file.path);\r\n        //console.log(\"filepath\", filePath);\r\n        file.contents = new Buffer(\r\n            // 匹配@import\r\n          String(file.contents).replace(\r\n            /@import\\s+['|\"](.+)['|\"];/g,\r\n            ($1, $2) => {\r\n              console.log(\"$1\", $1);\r\n              console.log(\"$2\", $2);\r\n              //如果不是变量或者mixin则注释掉\r\n              return DIRECTIMPORT.some(item => {\r\n                return $2.indexOf(item) > -1;\r\n              })\r\n                ? $1\r\n                : `/** ${$1} **/`;\r\n            }\r\n          )\r\n        );\r\n      })\r\n    )\r\n    .pipe(sass())\r\n    .pipe(postcss([autoprefixer([\"iOS >= 8\", \"Android >= 4.1\"])]))\r\n    .pipe(\r\n      replace(/(\\/\\*\\*\\s{0,})(@.+)(\\s{0,}\\*\\*\\/)/g, ($1, $2, $3) => {\r\n        //console.log(\"$1\", $1);\r\n        //console.log(\"$2\", $2);\r\n        //console.log(\"$3\", $3);\r\n        //去掉注释并修改scss后缀为wxss\r\n        return $3.replace(/\\.scss/g, \".wxss\");\r\n      })\r\n    )\r\n    .pipe(rename({ extname: \".wxss\" }))\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(wxss);\r\n复制代码压缩图片文件安装gulp-imagemin插件压缩图片。之前通过npm安装在使用的时候这个插件总是报错，后来发现是没有正确安装，瞎倒腾切换到cnpm或者yarn发现可以安装成功了。const imageFiles = [\r\n  `${srcPath}/images/*.{png,jpg,gif,ico}`,\r\n  `${srcPath}/images/**/*.{png,jpg,gif,ico}`\r\n];\r\nconst img = () => {\r\n  return gulp\r\n    .src(imageFiles, { since: gulp.lastRun(img) })\r\n    .pipe(imagemin())\r\n    .pipe(gulp.dest(distPath));\r\n};\r\ngulp.task(img);\r\n复制代码区分开发环境正常开发过程中，开发，测试和发布环境通常会有不同的API接口和其他设置。在每次切换的时候手动去更改内部代码是一件很麻烦的事情，也容易遗忘，根据不同的命令自动加载相应的开发环境设置才是我们想要的效果。 在 src/env/* 目录下，配置了三个环境的变量： dev.js ， test.js ， prod.js 。const envJs = env => {\r\n  return () => {\r\n    return gulp\r\n      .src(`./src/env/${env}.js`)\r\n      .pipe(rename(\"env.js\"))\r\n      .pipe(gulp.dest(distPath));\r\n  };\r\n};\r\ngulp.task(envJs);\r\n复制代码清除dist目录在重新编译的时候我们都需要清除dist目录的资源，以免导致混乱/* 清除dist目录 */\r\ngulp.task(\"clean\", done => {\r\n  del.sync([\"dist/**\"]);\r\n  done();\r\n});\r\n复制代码自动创建目录使用命令新建page目录和component目录，只要把模版文件拷贝并重命名即可。const newfile = done => {\r\n  yargs\r\n    .example(\"gulp newfile  -p mypage\", \"创建mypage的page目录\")\r\n    .example(\"gulp newfile  -c mycomponent\", \"创建mycomponent的component目录\")\r\n    .example(\r\n      \"gulp newfile  -s srcfile -p mypage\",\r\n      \"以srcfile为模版创建mypage的page目录\"\r\n    )\r\n    .option({\r\n      s: {\r\n        alias: \"src\",\r\n        describe: \"模板\",\r\n        type: \"string\",\r\n        default: \"template\"\r\n      },\r\n      p: {\r\n        alias: \"page\",\r\n        describe: \"page名称\",\r\n        type: \"string\"\r\n      },\r\n      c: {\r\n        alias: \"component\",\r\n        describe: \"component名称\",\r\n        type: \"string\"\r\n      }\r\n    })\r\n    .fail(msg => {\r\n      done();\r\n      console.error(\"创建失败\");\r\n      console.log(msg);\r\n      console.log(\"help\");\r\n      yargs.parse([\"--msg\"]);\r\n    })\r\n    .help(\"msg\");\r\n\r\n  const args = yargs.argv;\r\n  //console.log(\"args\", args);\r\n  const source = args.s;\r\n  const filePaths = {\r\n    p: \"pages\",\r\n    c: \"components\"\r\n  };\r\n\r\n  let name,\r\n    type,\r\n    hasParam = false;\r\n  for (let key in filePaths) {\r\n    if (args[key]) {\r\n      hasParam = true;\r\n      name = args[key];\r\n      type = filePaths[key];\r\n    }\r\n  }\r\n  if (!hasParam) {\r\n    done();\r\n    yargs.parse([\"--msg\"]);\r\n  }\r\n  const defaultPath =\r\n    source === \"template\"\r\n      ? `src/${source}/${type}/*`\r\n      : `src/${type}/${source}/*`;\r\n  return gulp.src(defaultPath).pipe(gulp.dest(`src/${type}/${name}/`));\r\n};\r\ngulp.task(newfile);\r\n复制代码"}
{"title": "微信PC版2.9.0测试版更新：语音消息自动转文字，小程序、小游戏来到桌面上 ... ", "author": "Rolan", "pub_time": "2020-3-26 00:03", "content": "这一周以来，微信团队相继推出了iOS版7.0.12版本、安卓版v7.0.13测试版本更新，带来了许多用户“骂”了许久才出来的深色模式，以及其他一些交互或者功能更新。此外，桌面版的微信客户端也有了新的2.9.0测试版本的更新，同样带来了许多用户迫切需要的一个功能，那就是语音消息自动转文字，简单测试效果还是相当不错的，需要的可以 点击这里直接下载 新版微信。除了语音消息自动转文字的功能之外，更加重磅的功能更新应该是新增小程序面板，可以查看最近使用和已经添加的小程序，对于日常上班需要使用桌面版微信而又有使用小程序习惯的小伙伴来说，再也不用电脑、手机两头用了。此外，在新版微信PC客户端当中，朋友分享的小游戏可以直接在聊天窗口中打开了，但是还是别在上班时间摸鱼打坦克大战了吧。在经历了今年以来的几个版本更新之后，微信桌面版客户端的使用在功能上是已经越来越接近移动端了，大家常用的功能除了朋友圈之外，像看一看等功能都已经相继搬到桌面端了，在使用上能够提供更加一致的使用体验。以下是微信团队提供的官方更新日志：新增小程序面板，可以查看最近使用和已添加的小程序聊天中可以引用更多类型的消息聊天中可以拖拽消息，以转发到其他聊天或保存到电脑可以设置聊天中的语音消息自动转为文字可以设置收到的文件是否自动下载"}
{"title": "微信朋友圈广告或将实现一键跳转小程序直播 ", "author": "Rolan", "pub_time": "2020-3-26 00:17", "content": "近期在开发小程序中，接触最多的就是 canvas 了，期间又因为兼容性的问题，又经历了底层 API 的新旧版的替换，踩的坑可谓令人印象深刻。小程序（微信）的 canvas 与 HTML 标准的 canvas 有较大区别，就连小程序本身的 canvas 底层 API 都有两个大版本的区别（其实远古时期还有一个版本，但年代过于久远就不做考究了）。目前现存的两个版本的区别在于是否支持「同层渲染」。同层渲染小程序的内容大多是渲染在 WebView 上的，如果把 WebView 看成单独的一层，那么由系统自带的这些原生组件则位于另一个更高的层级（如 canvas、video）。两个层级是完全独立的，因此无法简单地通过使用 z-index 控制原生组件和非原生组件之间的相对层级。想要在原生组件之上只能用 cover-view 和 cover-image 来实现。但 cover-view 和 cover-image 支持的 css 样式是在很有限，而且经过实践来看，cover-view 在安卓部分机器上性能真的很差。「同层渲染」则是将原生组件直接渲染到 WebView 层级上，就可以通过简单的 z-index 来控制层级，而且支持的 css 非常丰富，麻麻再也不用担心我碰到的层级问题了！是不是看起来很美好？然而现实非常残酷。「同层渲染」存在的问题首先，根据小程序官方的文章来看，几乎是重构了整个「原生组件」，使用方式和支持的特性与之前的区别都非常大，非常类似标准的 canvas API，甚至官方声称「支持标准 canvas 的大部分属性方法」。但是根据我的实际项目经验来看，新版 canvas API 仅仅只是在 iOS 上表现良好，在部分安卓机器上会出现许多怪异行为。一个简单的例子是绘制多个相同的形状时，画笔似乎会出现在「飘忽不定」的位置上，导致绘制最终结果无法预测。另外很让人头疼的一个地方在于 drawImage 方法上。旧版 API drawImage 第一个参数是图片路径，本地路径或网络路径皆可，但新版 API drawImage 第一个参数必须是图片实例，由于小程序无法获取 DOM 元素，只能用官方提供的 createImage 方法创建图片实例，在其 onLoad 回调中再次调用 drawImage ，才能实现原先简单的方法。诸如此类。但这些都是可以克服的，最终导致我们放弃的原因是其在部分安卓机器上的「不确定性」，如果在「新特性」和「兼容性」上做选择，我想我还是坚持选择「兼容性」吧。就好像「优雅降级」和「渐进增强」，我更倾向于后者。「兼容性」下的「同层渲染」我相信大多数做过小程序 canvas 相关都有层级的烦恼。既然无法使用新版 API 来实现，那问题总要解决，最终我们想出了一套在旧版 API 也可以实现类似「同层渲染」的效果。目前需要「同层渲染」的场景基本上都是需要在 canvas 上弹层，所以在覆盖 canvas 的时候不会同时操作 canvas，因为可以利用 canvasToTempFilePath 可以临时将 canvas 转成图片，然后隐藏 canvas，显示 tempImage 即可。黎明的曙光新版 canvas API 并不是一无是处，有一个很大的变化在于它不再使用物理尺寸来绘制，使用的是实际尺寸。这就会使得使用新版 API 绘制的结果比原来高清许多，这算是为数不多的优点吧。另外新版 canvas API 在 iOS 上表现还是很不错的。希望未来官方可以让新版 canvas API 兼容性更优秀，让开发者早日摆脱这些临时方案。"}
{"title": "京喜小程序的高性能打造之路 ", "author": "Rolan", "pub_time": "2020-3-27 00:26", "content": "本文阅读时长约15分钟。京喜小程序开发团队核心成员倾力之作，都是干货，读完一定会收获满满，请大家耐心阅读～背景京喜小程序自去年双十一上线微信购物一级入口后，时刻迎接着亿级用户量的挑战，细微的体验细节都有可能被无限放大，为此，“极致的页面性能”、“友好的产品体验” 和 “稳定的系统服务” 成为了我们开发团队的最基本执行原则。首页作为小程序的门户，其性能表现和用户留存率息息相关。因此，我们对京喜首页进行了一次全方位的升级改造，从加载、渲染和感知体验几大维度深挖小程序的性能可塑性。除此之外，京喜首页在微信小程序、H5、APP 三端都有落地场景，为了提高研发效率，我们使用了 Taro 框架实现多端统一，因此下文中有部分内容是和 Taro 框架息息相关的。怎么定义高性能？提起互联网应用性能这个词，很多人在脑海中的词法解析就是，“是否足够快？”，似乎加载速度成为衡量系统性能的唯一指标。但这其实是不够准确的，试想一下，如果一个小程序加载速度非常快，用户花费很短时间就能看到页面的主体内容，但此时搜索框却无法输入内容，功能无法被流畅使用，用户可能就不会关心页面渲染有多快了。所以，我们不应该单纯考虑速度指标而忽略用户的感知体验，而应该全方位衡量用户在使用过程中能感知到的与应用加载相关的每个节点。谷歌为 Web 应用定义了以用户为中心的性能指标体系，每个指标都与用户体验节点息息相关：其中，“是否有用？” 这个问题是非常主观的，对于不同场景的系统可能会有完全不一样的回答，所以 FMP 是一个比较模糊的概念指标，不存在规范化的数值衡量。小程序作为一个新的内容载体，衡量指标跟 Web 应用是非常类似的。对于大多数小程序而言，上述指标对应的含义为：FCP：白屏加载结束；FMP：首屏渲染完成；TTI：所有内容加载完成；综上，我们已基本确定了高性能的概念指标，接下来就是如何利用数值指标来描绘性能表现。小程序官方性能指标小程序官方针对小程序性能表现制订了权威的数值指标，主要围绕 渲染表现 、 setData 数据量 、 元素节点数 和 网络请求延时 这几个维度来给予定义（下面只列出部分关键指标）：首屏时间不超过 5 秒；渲染时间不超过 500ms；每秒调用 setData 的次数不超过 20 次；setData 的数据在 JSON.stringify 后不超过 256kb；页面 WXML 节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个；所有网络请求都在 1 秒内返回结果；详见 小程序性能评分规则我们应该把这一系列的官方指标作为小程序的性能及格线，不断地打磨和提升小程序的整体体验，降低用户流失率。另外，这些指标会直接作为小程序体验评分工具的性能评分规则（体验评分工具会根据这些规则的权重和求和公式计算出体验得分）。我们团队内部在官方性能指标的基础上，进一步浓缩优化指标系数，旨在对产品体验更高要求：setData\r\n体验评分工具小程序提供了 体验评分工具（ Audits 面板） 来测量上述的指标数据，其集成在开发者工具中，在小程序运行时实时检查相关问题点，并为开发者给出优化建议。以上截图均来自小程序官方文档体验评分工具是目前检测小程序性能问题最直接有效的途径，我们团队已经把体验评分作为页面/组件是否能达到精品门槛的重要考量手段之一。小程序后台性能分析我们知道，体验评分工具是在本地运行小程序代码时进行分析，但性能数据往往需要在真实环境和大数据量下才更有说服力。恰巧， 小程序管理平台 和 小程序助手 为开发者提供了大量的真实数据统计。其中，性能分析面板从 启动性能 、 运行性能 和 网络性能 这三个维度分析数据，开发者可以根据客户端系统、机型、网络环境和访问来源等条件做精细化分析，非常具有考量价值。其中，启动总耗时 = 小程序环境初始化 + 代码包加载 + 代码执行 + 渲染耗时第三方测速系统很多时候，宏观的耗时统计对于性能瓶颈点分析往往是杯水车薪，作用甚少，我们需要更细致地针对某个页面某些关键节点作测速统计，排查出暴露性能问题的代码区块，才能更有效地针对性优化。京喜小程序使用的是内部自研的测速系统，支持对地区、运营商、网络、客户端系统等多条件筛选，同时也支持数据可视化、同比分析数据等能力。京喜首页主要围绕 页面 onLoad 、 onReady 、 数据加载完成 、 首屏渲染完成 、 各业务组件首次渲染完成 等几个关键节点统计测速上报，旨在全链路监控性能表现。另外，微信为开发者提供了 测速系统 ，也支持针对客户端系统、网络类型、用户地区等维度统计数据，有兴趣的可以尝试。了解小程序底层架构为了更好地为小程序制订性能优化措施，我们有必要先了解小程序的底层架构，以及与 web 浏览器的差异性。微信小程序是大前端跨平台技术的其中一种产物，与当下其他热门的技术 React Native、Weex、Flutter 等不同，小程序的最终渲染载体依然是浏览器内核，而不是原生客户端。而对于传统的网页来说，UI 渲染和 JS 脚本是在同一个线程中执行，所以经常会出现 “阻塞” 行为。微信小程序基于性能的考虑，启用了 双线程模型 ：视图层 ：也就是 webview 线程，负责启用不同的 webview 来渲染不同的小程序页面；逻辑层 ：一个单独的线程执行 JS 代码，可以控制视图层的逻辑；上图来自小程序官方开发指南然而， 任何线程间的数据传输都是有延时的 ，这意味着逻辑层和视图层间通信是异步行为。除此之外，微信为小程序提供了很多客户端原生能力，在调用客户端原生能力的过程中，微信主线程和小程序双线程之间也会发生通信，这也是一种异步行为。这种异步延时的特性会使运行环境复杂化，稍不注意，就会产出效率低下的编码。作为小程序开发者，我们常常会被下面几个问题所困扰：小程序启动慢；白屏时间长；页面渲染慢；运行内存不足；接下来，我们会结合小程序的底层架构分析出这些问题的根本原因，并针对性地给出解决方案。小程序启动太慢？小程序启动阶段，也就是如下图所示的展示加载界面的阶段。在这个阶段中（包括启动前后的时机），微信会默默完成下面几项工作：1. 准备运行环境：在小程序启动前，微信会先启动双线程环境，并在线程中完成小程序基础库的初始化和预执行。小程序基础库包括 WebView 基础库和 AppService 基础库，前者注入到视图层中，后者注入到逻辑层中，分别为所在层级提供其运行所需的基础框架能力。2. 下载小程序代码包：在小程序初次启动时，需要下载编译后的代码包到本地。如果启动了小程序分包，则只有主包的内容会被下载。另外，代码包会保留在缓存中，后续启动会优先读取缓存。3. 加载小程序代码包：小程序代码包下载好之后，会被加载到适当的线程中执行，基础库会完成所有页面的注册。在页面注册过程中，基础库会调用页面 JS 文件的 Page 构造器方法，来记录页面的基础信息（包括初始数据、方法等）。4. 初始化小程序首页：在小程序代码包加载完之后，基础库会根据启动路径找到首页，根据首页的基础信息初始化一个页面实例，并把信息传递给视图层，视图层会结合 WXML 结构、WXSS 样式和初始数据来渲染界面。综合考虑，为了节省小程序的“点点点”时间（小程序的启动动画是三个圆点循环跑马灯），除了给每位用户发一台高配 5G 手机并顺带提供千兆宽带网络之外，还可以尽量 控制代码包大小 ，缩小代码包的下载时间。无用文件、函数、样式剔除经过多次业务迭代，无可避免的会存在一些弃用的组件/页面，以及不被调用的函数、样式规则，这些冗余代码会白白占据宝贵的代码包空间。而且，目前小程序的打包会将工程下所有文件都打入代码包内，并没有做依赖分析。因此，我们需要及时地剔除不再使用的模块，以保证代码包空间利用率保持在较高水平。通过一些工具化手段可以有效地辅助完成这一工作。文件依赖分析在小程序中，所有页面的路径都需要在小程序代码根目录 app.json 中被声明，类似地，自定义组件也需要在页面配置文件 page.json 中被声明。另外，WXML、WXSS 和 JS 的模块化都需要特定的关键字来声明依赖引用关系。WXML 中的 import 和 include ：<!-- A.wxml -->\r\n<template name='A'>\r\n  <text>{{text}}</text>\r\n</template>\r\n\r\n<!-- B.wxml -->\r\n<import src=\"A.wxml\"/>\r\n<template is=\"A\" data=\"{{text: 'B'}}\"/><!-- A.wxml -->\r\n<text> A </text>\r\n\r\n<!-- B.wxml -->\r\n<include src=\"A.wxml\"/>\r\n<text> B </text>WXSS 中的 @import ：@import './A.wxss'JS 中的 require / import ：const A = require('./A')所以，可以说小程序里的所有依赖模块都是有迹可循的，我们只需要利用这些关键字信息递归查找，遍历出文件依赖树，然后把没用的模块剔除掉。JS、CSS Tree-ShakingJS Tree-Shaking 的原理就是借助 Babel 把代码编译成抽象语法树（AST），通过 AST 获取到函数的调用关系，从而把未被调用的函数方法剔除掉。不过这需要依赖 ES module，而小程序最开始是遵循 CommonJS 规范的，这意味着是时候来一波“痛并快乐着”的改造了。而 CSS 的 Tree-Shaking 可以利用 PurifyCSS 插件来完成。关于这两项技术，有兴趣的可以“谷歌一下”，这里就不铺开细讲了。题外，京东的小程序团队已经把这一系列工程化能力集成在一套 CLI 工具中，有兴趣的可以看看这篇分享： 小程序工程化探索 。减少代码包中的静态资源文件小程序代码包最终会经过 GZIP 压缩放在 CDN 上，但 GZIP 压缩对于图片资源来说效果非常低。如 JPG 、 PNG 等格式文件，本身已经被压缩过了，再使用 GZIP 压缩有可能体积更大，得不偿失。所以，除了部分用于容错的图片必须放在代码包（譬如网络异常提示）之外，建议开发者把图片、视频等静态资源都放在 CDN 上。需要注意， Base64 格式本质上是长字符串，和 CDN 地址比起来也会更占空间。逻辑后移，精简业务逻辑这是一个 “痛并快乐着” 的优化措施。“痛” 是因为需要给后台同学提改造需求，分分钟被打；“快乐” 则是因为享受删代码的过程，而且万一出 Bug 也不用背锅了...（开个玩笑）通过让后台承担更多的业务逻辑，可以节省小程序前端代码量，同时线上问题还支持紧急修复，不需要经历小程序的提审、发布上线等繁琐过程。总结得出， 一般不涉及前端计算的展示类逻辑，都可以适当做后移 。譬如京喜首页中的幕帘弹窗（如下图）逻辑，这里共有 10+ 种弹窗类型，以前的做法是前端从接口拉取 10+ 个不同字段，根据优先级和 “是否已展示”（该状态存储在本地缓存） 来决定展示哪一种，最后代码大概是这样的：// 检查每种弹窗类型是否已展示\r\nPromise.all([\r\n  check(popup_1),\r\n  check(popup_2),\r\n  // ...\r\n  check(popup_n)\r\n]).then(result => {\r\n  // 优先级排序\r\n  const queue = [{\r\n    show: result.popup_1\r\n    data: data.popup_1\r\n  }, {\r\n    show: result.popup_2\r\n    data: data.popup_2\r\n  }, \r\n  // ...\r\n  {\r\n    show: result.popup_n\r\n    data: data.popup_n\r\n  }]\r\n})逻辑后移之后，前端只需负责拿幕帘字段做展示就可以了，代码变成这样：this.setData({\r\n  popup: data.popup\r\n})复用模板插件京喜首页作为电商系统的门户，需要应对各类频繁的营销活动、升级改版等，同时也要满足不同用户属性的界面个性化需求（俗称 “千人千面”）。如何既能减少为应对多样化场景而产生的代码量，又可以提升研发效率，成为燃眉之急。类似于组件复用的理念，我们需要提供更丰富的可配置能力，实现更高的代码复用度。参考小时候很喜欢玩的 “乐高” 积木玩具， 我们把首页模块的模板元素作颗粒度更细的划分，根据样式和功能抽象出一块块“积木”原料（称为插件元素） 。当首页模块在处理接口数据时，会启动插件引擎逐个装载插件，最终输出个性化的模板样式，整个流程就好比堆积木。当后续产品/运营需要新增模板时，只要在插件库中挑选插件排列组合即可，不需要额外新增/修改组件内容，也更不会产生难以维护的 if / else 逻辑，so easy～当然，要完成这样的插件化改造免不了几个先决条件：用户体验设计的统一 。如果设计风格总是天差地别的，强行插件化只会成为累赘。服务端接口的统一 。同上，如果得浪费大量的精力来兼容不同模块间的接口字段差异，将会非常蛋疼。下面为大家提供部分例程来辅助理解。其中， use 方法会接受各类处理钩子最终拼接出一个 Function ，在对应模块处理数据时会被调用。// bi.helper.js\r\n\r\n/**\r\n * 插件引擎\r\n * @param {function} options.formatName 标题处理钩子\r\n * @param {function} options.validList 数据校验器钩子\r\n */ \r\nconst use = options => data => format(data)\r\n\r\n/**\r\n * 预置插件库\r\n */ \r\nnameHelpers = {\r\n  text: data => data.text,\r\n  icon: data => data.icon\r\n}\r\nlistHelpers = {\r\n  single: list => list.slice(0, 1),\r\n  double: list => list.slice(0, 2)\r\n}\r\n\r\n/**\r\n * “堆积木”\r\n */\r\nexport default {\r\n  1000: use({\r\n    formatName: nameHelpers.text,\r\n    validList: listHelpers.single\r\n  }),\r\n\r\n  1001: use({\r\n    formatName: nameHelpers.icon,\r\n    validList: listHelpers.double\r\n  })\r\n}<!-- bi.wxml -->\r\n<!-- 各模板节点实现 -->\r\n<template name=\"renderName\">\r\n  <view wx:if=\"{{type === 'text'}}\"> text </view>\r\n  <view wx:elif=\"{{type === 'icon'}}\"> icon </view>\r\n</template>\r\n\r\n<view class=\"bi__name\">\r\n  <template is=\"renderName\" data=\"{{...data.name}\"/>\r\n</view>// bi.js\r\nComponent({\r\n  ready() {\r\n    // 根据 tpl 值选择解析函数\r\n    const formatData = helper[data.tpl]\r\n    this.setData({\r\n      data: formatData(data)\r\n    })\r\n  }\r\n})分包加载小程序启动时只会下载主包/独立分包，启用分包可以有效减少下载时间。（独立）分包需要遵循一些原则，详细的可以看官方文档：使用分包独立分包部分页面 h5 化小程序提供了 web-view 组件，支持在小程序环境内访问网页。当实在无法在小程序代码包中腾出多余空间时，可以考虑降级方案 —— 把部分页面 h5 化。小程序和 h5 的通信可以通过 JSSDK 或 postMessage 通道来实现，详见 小程序开发文档 。白屏时间过长？白屏阶段，是指小程序代码包下载完（也就是启动界面结束）之后，页面完成首屏渲染的这一阶段，也就是 FMP (首次有效绘制)。FMP 没法用标准化的指标定义，但对于大部分小程序来说，页面首屏展示的内容都需要依赖服务端的接口数据，那么影响白屏加载时间的主要由这两个元素构成：网络资源加载时间 ；渲染时间 ；启用本地缓存小程序提供了读写本地缓存的接口，数据存储在设备硬盘上。由于本地 I/O 读写（毫秒级）会比网络请求（秒级）要快很多，所以在用户访问页面时，可以优先从缓存中取上一次接口调用成功的数据来渲染视图，待网络请求成功后再覆盖最新数据重新渲染。除此之外，缓存数据还可以作为兜底数据，避免出现接口请求失败时页面空窗，一石二鸟。但并非所有场景都适合缓存策略，譬如对数据即时性要求非常高的场景（如抢购入口）来说，展示老数据可能会引发一些问题。小程序默认会按照 不同小程序 、 不同微信用户 这两个维度对缓存空间进行隔离。诸如京喜小程序首页也采用了缓存策略，会进一步按照 数据版本号 、 用户属性 来对缓存进行再隔离，避免信息误展示。数据预拉取小程序官方为开发者提供了一个在小程序冷启动时提前拉取第三方接口的能力： 数据预拉取 。关于冷启动和热启动的定义可以看 这里数据预拉取的原理其实很简单，就是在小程序启动时，微信服务器代理小程序客户端发起一个 HTTP 请求到第三方服务器来获取数据，并且把响应数据存储在本地客户端供小程序前端调取。当小程序加载完成后，只需调用微信提供的 API wx.getBackgroundFetchData 从本地缓存获取数据即可。这种做法可以充分利用小程序启动和初始化阶段的等待时间，使更快地完成页面渲染。京喜小程序首页已经在生产环境实践过这个能力，从每日千万级的数据分析得出，预拉取使冷启动时获取到接口数据的时间节点从 2.5s 加速到 1s（提速了 60%）。虽然提升效果非常明显，但这个能力依然存在一些不成熟的地方：预拉取的数据会被强缓存；由于预拉取的请求最终是由微信的服务器发起的，也许是出于服务器资源限制的考虑，预拉取的数据会缓存在微信本地一段时间，缓存失效后才会重新发起请求。经过真机实测，在微信购物入口冷启动京喜小程序的场景下，预拉取缓存存活了 30 分钟以上，这对于数据实时性要求比较高的系统来说是非常致命的。请求体和响应体都无法被拦截；由于请求第三方服务器是从微信的服务器发起的，而不是从小程序客户端发起的，所以本地代理无法拦截到这一次真实请求，这会导致开发者无法通过拦截请求的方式来区分获取线上环境和开发环境的数据，给开发调试带来麻烦。小程序内部接口的响应体类型都是 application/octet-stream ，即数据格式未知，使本地代理无法正确解析。微信服务器发起的请求没有提供区分线上版和开发版的参数，且没有提供用户 IP 等信息 ；如果这几个问题点都不会影响到你的场景，那么可以尝试开启预拉取能力，这对于小程序首屏渲染速度是质的提升。跳转时预拉取为了尽快获取到服务端数据，比较常见的做法是在页面 onLoad 钩子被触发时发起网络请求，但其实这并不是最快的方式。从发起页面跳转，到下一个页面 onLoad 的过程中，小程序需要完成一些环境初始化及页面实例化的工作，耗时大概为 300 ~ 400 毫秒。实际上，我们可以在发起跳转前（如 wx.navigateTo 调用前），提前请求下一个页面的主接口并存储在全局 Promise 对象中，待下个页面加载完成后从 Promise 对象中读取数据即可。这也是双线程模型所带来的优势之一，不同于多页面 web 应用在页面跳转/刷新时就销毁掉 window 对象。分包预下载如果开启了分包加载能力，在用户访问到分包内某个页面时，小程序才会开始下载对应的分包。当处于分包下载阶段时，页面会维持在 “白屏” 的启动态，这用户体验是比较糟糕的。幸好，小程序提供了 分包预下载 能力，开发者可以配置进入某个页面时预下载可能会用到的分包，避免在页面切换时僵持在 “白屏” 态。非关键渲染数据延迟请求这是关键渲染路径优化的其中一个思路，从缩短网络请求时延的角度加快首屏渲染完成时间。关键渲染路径（Critical Rendering Path） 是指在完成首屏渲染的过程中必须发生的事件。以京喜小程序如此庞大的小程序项目为例，每个模块背后都可能有着海量的后台服务作支撑，而这些后台服务间的通信和数据交互都会存在一定的时延。我们根据京喜首页的页面结构，把所有模块划分成两类： 主体模块 （导航、商品轮播、商品豆腐块等）和 非主体模块 （幕帘弹窗、右侧挂件等）。在初始化首页时，小程序会发起一个聚合接口请求来获取主体模块的数据，而非主体模块的数据则从另一个接口获取，通过拆分的手段来降低主接口的调用时延，同时减少响应体的数据量，缩减网络传输时间。分屏渲染这也是关键渲染路径优化思路之一，通过延迟非关键元素的渲染时机，为关键渲染路径腾出资源。类似上一条措施，继续以京喜小程序首页为例，我们在 主体模块 的基础上再度划分出 首屏模块 （商品豆腐块以上部分） 和 非首屏模块 （商品豆腐块及以下部分）。当小程序获取到主体模块的数据后，会优先渲染首屏模块，在所有首屏模块都渲染完成后才会渲染非首屏模块和非主体模块，以此确保首屏内容以最快速度呈现。为了更好地呈现效果，上面 gif 做了降速处理接口聚合，请求合并在小程序中，发起网络请求是通过 wx.request 这个 API。我们知道，在 web 浏览器中，针对同一域名的 HTTP 并发请求数是有限制的；在小程序中也有类似的限制，但区别在于不是针对域名限制，而是针对 API 调用：wx.request\r\nwx.connectSocket\r\n超出并发限制数目的 HTTP 请求将会被阻塞，需要在队列中等待前面的请求完成，从而一定程度上增加了请求时延。因此， 对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端。图片资源优化图片资源一直是移动端系统中抢占大流量的部分，尤其是对于电商系统。优化图片资源的加载可以有效地加快页面响应时间，提升首屏渲染速度。使用 WebP 格式WebP 是 Google 推出的一种支持有损/无损压缩的图片文件格式，得益于更优的图像数据压缩算法，其与 JPG、PNG 等格式相比，在肉眼无差别的图片质量前提下具有更小的图片体积（据官方说明，WebP 无损压缩体积比 PNG 小 26%，有损压缩体积比 JPEG 小 25-34%）。小程序的 image 组件 支持 JPG、PNG、SVG、WEBP、GIF 等格式。图片裁剪&降质鉴于移动端设备的分辨率是有上限的，很多图片的尺寸常常远大于页面元素尺寸，这非常浪费网络资源（一般图片尺寸 2 倍于页面元素真实尺寸比较合适）。得益于京东内部强大的图片处理服务，我们可以通过资源的命名规则和请求参数来获取服务端优化后的图片：裁剪成 100x100 的图片： https://{host}/s100x100_jfs/{file_path} ；降质 70%： https://{href}!q70 ；图片懒加载、雪碧图（CSS Sprite）优化这两者都是比较老生常谈的图片优化技术，这里就不打算细讲了。小程序的 image 组件 自带 lazy-load 懒加载支持。雪碧图技术（CSS Sprite）可以参考 w3schools 的教程。降级加载大图资源在不得不使用大图资源的场景下，我们可以适当使用 “体验换速度” 的措施来提升渲染性能。小程序会把已加载的静态资源缓存在本地，当短时间内再次发起请求时会直接从缓存中取资源（与浏览器行为一致）。因此，对于大图资源， 我们可以先呈现高度压缩的模糊图片，同时利用一个隐藏的 <image> 节点来加载原图，待原图加载完成后再转移到真实节点上渲染 。整个流程，从视觉上会感知到图片从模糊到高清的过程，但与对首屏渲染的提升效果相比，这点体验落差是可以接受的。下面为大家提供部分例程：<!-- banner.wxml -->\r\n<image src=\"{{url}}\" />\r\n\r\n<!-- 图片加载器 -->\r\n<image\r\n  style=\"width:0;height:0;display:none\"\r\n  src=\"{{preloadUrl}}\"\r\n  bindload=\"onImgLoad\"\r\n  binderror=\"onErrorLoad\"\r\n/>// banner.js\r\nComponent({\r\n  ready() {\r\n    this.originUrl = 'https://path/to/picture'  // 图片源地址\r\n    this.setData({\r\n      url: compress(this.originUrl)             // 加载压缩降质的图片\r\n      preloadUrl: this.originUrl                // 预加载原图\r\n    })\r\n  },\r\n  methods: {\r\n    onImgLoad() {\r\n      this.setData({\r\n        url: this.originUrl                       // 加载原图\r\n      })\r\n    }\r\n  }\r\n})注意，具有 display: none 样式的 <image> 标签只会加载图片资源，但不渲染。京喜首页的商品轮播模块也采用了这种降级加载方案，在首屏渲染时只会加载第一帧降质图片。以每帧原图 20~50kb 的大小计算，这一措施可以在初始化阶段节省掉几百 kb 的网络资源请求。为了更好地呈现效果，上面 gif 做了降速处理骨架屏一方面，我们可以从降低网络请求时延、减少关键渲染的节点数这两个角度出发，缩短完成 FMP（首次有效绘制）的时间。另一方面，我们也需要从用户感知的角度优化加载体验。“白屏” 的加载体验对于首次访问的用户来说是难以接受的，我们可以使用尺寸稳定的骨架屏，来辅助实现真实模块占位和瞬间加载。骨架屏目前在业界被广泛应用，京喜首页选择使用灰色豆腐块作为骨架屏的主元素，大致勾勒出各模块主体内容的样式布局。由于微信小程序不支持 SSR（服务端渲染），使动态渲染骨架屏的方案难以实现，因此京喜首页的骨架屏是通过 WXSS 样式静态渲染的。有趣的是，京喜首页的骨架屏方案经历了 “统一管理” 和 “（组件）独立管理” 两个阶段。出于避免对组件的侵入性考虑，最初的骨架屏是由一个完整的骨架屏组件统一管理的：<!-- index.wxml -->\r\n<skeleton wx:if=\"{{isLoading}}\"></skeleton>\r\n<block wx:else>\r\n  页面主体\r\n</block>但这种做法的维护成本比较高，每次页面主体模块更新迭代，都需要在骨架屏组件中的对应节点同步更新（譬如某个模块的尺寸被调整）。除此之外，感官上从骨架屏到真实模块的切换是跳跃式的，这是因为骨架屏组件和页面主体节点之间的关系是整体条件互斥的，只有当页面主体数据 Ready（或渲染完毕）时才会把骨架屏组件销毁，渲染（或展示）主体内容。为了使用户感知体验更加丝滑，我们把骨架屏元素拆分放到各个业务组件中，骨架屏元素的显示/隐藏逻辑由业务组件内部独立管理，这就可以轻松实现 “谁跑得快，谁先出来” 的并行加载效果。除此之外，骨架屏元素与业务组件共用一套 WXML 节点，且相关样式由公共的 sass 模块集中管理，业务组件只需要在适当的节点挂上 skeleton 和 skeleton__block 样式块即可，极大地降低了维护成本。<!-- banner.wxml -->\r\n<view class=\"{{isLoading ? 'banner--skeleton' : ''}}\">\r\n  <view class=\"banner_wrapper\"></view>\r\n</view>// banner.scss\r\n.banner--skeleton {\r\n  @include skeleton;\r\n  .banner_wrapper {\r\n    @include skeleton__block;\r\n  }\r\n}上面的 gif 在压缩过程有些小问题，大家可以直接访问【京喜】小程序体验骨架屏效果。如何提升渲染性能？当调用 wx.navigateTo 打开一个新的小程序页面时，小程序框架会完成这几步工作：1. 准备新的 webview 线程环境，包括基础库的初始化；2. 从逻辑层到视图层的初始数据通信；3. 视图层根据逻辑层的数据，结合 WXML 片段构建出节点树（包括节点属性、事件绑定等信息），最终与 WXSS 结合完成页面渲染；由于微信会提前开始准备 webview 线程环境，所以小程序的渲染损耗主要在后两者 数据通信和 节点树创建/更新 的流程中。相对应的，比较有效的渲染性能优化方向就是：降低线程间通信频次；减少线程间通信的数据量；减少 WXML 节点数量；合并 setData 调用尽可能地把多次 setData 调用合并成一次。我们除了要从编码规范上践行这个原则，还可以通过一些技术手段降低 setData 的调用频次。譬如，把同一个时间片（ 事件循环 ）内的 setData 调用合并在一起，Taro 框架就使用了这个优化手段。在 Taro 框架下，调用 setState 时提供的对象会被加入到一个数组中，当下一次事件循环执行的时候再把这些对象合并一起，通过 setData 传递给原生小程序。// 小程序里的时间片 API\r\nconst nextTick = wx.nextTick ? wx.nextTick : setTimeout;只把与界面渲染相关的数据放在 data 中不难得出， setData 传输的数据量越多，线程间通信的耗时越长，渲染速度就越慢。根据微信官方测得的数据，传输时间和数据量大体上呈正相关关系：上图来自小程序官方开发指南所以，与视图层渲染无关的数据尽量不要放在 data 中，可以放在页面（组件）类的其他字段下。应用层的数据 diff每当调用 setData 更新数据时，会引起视图层的重新渲染，小程序会结合新的 data 数据和 WXML 片段构建出新的节点树，并与当前节点树进行比较得出最终需要更新的节点（属性）。即使小程序在底层框架层面已经对节点树更新进行了 diff，但我们依旧可以优化这次 diff 的性能。譬如，在调用 setData 时，提前确保传递的所有新数据都是有变化的，也就是针对 data 提前做一次 diff。Taro 框架内部做了这一层优化。在每次调用原生小程序的 setData 之前，Taro 会把最新的 state 和当前页面实例的 data 做一次 diff，筛选出有必要更新的数据再执行 setData 。附 Taro 框架的 数据 diff 规则去掉不必要的事件绑定当用户事件（如 Click 、 Touch 事件等）被触发时，视图层会把事件信息反馈给逻辑层，这也是一个线程间通信的过程。但，如果没有在逻辑层中绑定事件的回调函数，通信将不会被触发。所以，尽量减少不必要的事件绑定，尤其是像 onPageScroll 这种会被频繁触发的用户事件，会使通信过程频繁发生。去掉不必要的节点属性组件节点支持附加自定义数据 dataset （见下面例子），当用户事件被触发时，视图层会把事件 target 和 dataset 数据传输给逻辑层。那么，当自定义数据量越大，事件通信的耗时就会越长，所以应该避免在自定义数据中设置太多数据。<!-- wxml -->\r\n<view\r\n  data-a='A'\r\n  data-b='B'\r\n  bindtap='bindViewTap'\r\n>\r\n  Click Me!\r\n</view>// js\r\nPage({\r\n  bindViewTap(e) {\r\n    console.log(e.currentTarget.dataset)\r\n  }\r\n})适当的组件颗粒度小程序的组件模型与 Web Components 标准中的 ShadowDOM 非常类似，每个组件都有独立的节点树，拥有各自独立的逻辑空间（包括独立的数据、 setData 调用、 createSelectorQuery执行域等）。不难得出，如果自定义组件的颗粒度太粗，组件逻辑过重，会影响节点树构建和新/旧节点树 diff 的效率，从而影响到组件内 setData 的性能。另外，如果组件内使用了 createSelectorQuery来查找节点，过于庞大的节点树结构也会影响查找效率。我们来看一个场景，京喜首页的 “京东秒杀” 模块涉及到一个倒计时特性，是通过 setInterval每秒调用 setData 来更新表盘时间。我们通过把倒计时抽离出一个基础组件，可以有效降低频繁 setData 时的性能影响。适当的组件化，既可以减小数据更新时的影响范围，又能支持复用，何乐而不为？诚然，并非组件颗粒度越细越好，组件数量和小程序代码包大小是正相关的。尤其是对于使用编译型框架（如 Taro）的项目，每个组件编译后都会产生额外的运行时代码和环境 polyfill，so，为了代码包空间，请保持理智...事件总线，替代组件间数据绑定的通信方式WXML 数据绑定是小程序中父组件向子组件传递动态数据的较为常见的方式，如下面例程所示： Component A 组件中的变量 a 、 b 通过组件属性传递给 Component B 组件。在此过程中，不可避免地需要经历一次 Component A 组件的 setData 调用方可完成任务，这就会产生线程间的通信。“合情合理”，但，如果传递给子组件的数据只有一部分是与视图渲染有关呢？<!-- Component A -->\r\n<component-b prop-a=\"{{a}}\" prop-b=\"{{b}}\" />// Component B\r\nComponent({\r\n  properties: {\r\n    propA: String,\r\n    propB: String,\r\n  },\r\n  methods: {\r\n    onLoad: function() {\r\n      this.data.propA\r\n      this.data.propB\r\n    }\r\n  }\r\n})推荐一种特定场景下非常便捷的做法：通过事件总线（EventBus），也就是发布/订阅模式，来完成由父向子的数据传递。其构成非常简单（例程只提供关键代码...）：一个全局的事件调度中心class EventBus {\r\n  constructor() {\r\n    this.events = {}\r\n  }\r\n\r\n  on(key, cb) { this.events[key].push(cb) }\r\n\r\n  trigger(key, args) { \r\n    this.events[key].forEach(function (cb) {\r\n      cb.call(this, ...args)\r\n    })\r\n  }\r\n  \r\n  remove() {}\r\n}\r\n\r\nconst event = new EventBus()事件订阅者// 子组件\r\nComponent({\r\n  created() {\r\n    event.on('data-ready', (data) => { this.setData({ data }) })\r\n  }\r\n})事件发布者// Parent\r\nComponent({\r\n  ready() {\r\n    event.trigger('data-ready', data)\r\n  }\r\n})子组件被创建时事先监听数据下发事件，当父组件获取到数据后触发事件把数据传递给子组件，这整个过程都是在小程序的逻辑层里同步执行，比数据绑定的方式速度更快。但并非所有场景都适合这种做法。像京喜首页这种具有 “数据单向传递” 、 “展示型交互” 特性、且 一级子组件数量庞大 的场景，使用事件总线的效益将会非常高；但若是频繁 “双向数据流“ 的场景，用这种方式会导致事件交错难以维护。题外话，Taro 框架在处理父子组件间数据传递时使用的是观察者模式，通过 Object.defineProperty 绑定父子组件关系，当父组件数据发生变化时，会递归通知所有后代组件检查并更新数据。这个通知的过程会同步触发数据 diff 和一些校验逻辑，每个组件跑一遍大概需要 5 ~ 10 ms 的时间。所以，如果组件量级比较大，整个流程下来时间损耗还是不小的，我们依旧可以尝试事件总线的方案。组件层面的 diff我们可能会遇到这样的需求，多个组件之间位置不固定，支持随时随地灵活配置，京喜首页也存在类似的诉求。京喜首页主体可被划分为若干个业务组件（如搜索框、导航栏、商品轮播等），这些业务组件的顺序是不固定的，今天是搜索框在最顶部，明天有可能变成导航栏在顶部了（夸张了...）。我们不可能针对多种顺序可能性提供多套实现，这就需要用到小程序的自定义模板 <template> 。实现一个支持调度所有业务组件的模板，根据后台下发的模块数组按序循环渲染模板，如下面例程所示。<!-- index.wxml -->\r\n<template name=\"render-component\">\r\n  <search-bar wx:if=\"{{compId === 'SearchBar'}}\" floor-id=\"{{index}}\" />\r\n  <nav-bar wx:if=\"{{compId === 'NavBar'}}\" floor-id=\"{{index}}\" />\r\n  <banner wx:if=\"{{compId === 'Banner'}}\" floor-id=\"{{index}}\" />\r\n  <icon-nav wx:if=\"{{compId === 'IconNav'}}\" floor-id=\"{{index}}\" />\r\n</template>\r\n\r\n<view\r\n  class=\"component-wrapper\"\r\n  wx:for=\"{{comps}}\"\r\n  wx:for-item=\"comp\"\r\n>\r\n  <template is=\"render-component\" data=\"{{...comp}}\"/>\r\n</view>// search-bar.js\r\nComponent({\r\n  properties: {\r\n    floorId: Number,\r\n  },\r\n  created() {\r\n    event.on('data-ready', (comps) => {\r\n      const data = comps[this.data.floorId] // 根据楼层位置取数据\r\n    })\r\n  }\r\n})貌似非常轻松地完成需求，但值得思考的是： 如果组件顺序调整了，所有组件的生命周期会发生什么变化？假设，上一次渲染的组件顺序是 ['search-bar'，'nav-bar'，'banner', 'icon-nav'] ，现在需要把 nav-bar 组件去掉，调整为 ['search-bar'，'banner', 'icon-nav'] 。经实验得出， 当某个组件节点发生变化时，其前面的组件不受影响，其后面的组件都会被销毁重新挂载。原理很简单，每个组件都有各自隔离的节点树（ ShadowTree ），页面 body 也是一个节点树。在调整组件顺序时，小程序框架会遍历比较新/旧节点树的差异，于是发现新节点树的 nav-bar 组件节点不见了，就认为该（树）分支下从 nav-bar 节点起发生了变化，往后节点都需要重渲染。但实际上，这里的组件顺序是没有变化的，丢失的组件按道理不应该影响到其他组件的正常渲染。所以，我们在 setData 前先进行了新旧组件列表 diff： 如果 newList 里面的组件是 oldList 的子集，且相对顺序没有发生变化，则所有组件不重新挂载 。除此之外，我们还要在接口数据的相应位置填充上空数据，把该组件隐藏掉，done。通过组件 diff 的手段，可以有效降低视图层的渲染压力，如果有类似场景的朋友，也可以参考这种方案。内存占用过高？想必没有什么会比小程序 Crash 更影响用户体验了。当小程序占用系统资源过高，就有可能会被系统销毁或被微信客户端主动回收。应对这种尴尬场景，除了提示用户提升硬件性能之外（譬如来京东商城买新手机），还可以通过一系列的优化手段降低小程序的内存损耗。内存预警小程序提供了监听内存不足告警事件的 API： wx.onMemoryWarning ，旨在让开发者收到告警时及时释放内存资源避免小程序 Crash。然而对于小程序开发者来说，内存资源目前是无法直接触碰的，最多就是调用 wx.reLaunch 清理所有页面栈，重载当前页面，来降低内存负荷（此方案过于粗暴，别冲动，想想就好...）。不过内存告警的信息收集倒是有意义的，我们可以把内存告警信息（包括页面路径、客户端版本、终端手机型号等）上报到日志系统，分析出哪些页面 Crash 率比较高，从而针对性地做优化，降低页面复杂度等等。回收后台页面计时器根据双线程模型，小程序每一个页面都会独立一个 webview 线程，但逻辑层是单线程的，也就是所有的 webview 线程共享一个 JS 线程。以至于当页面切换到后台态时，仍然有可能抢占到逻辑层的资源，譬如没有销毁的 setInterval 、 setTimeout 定时器：// Page A\r\nPage({\r\n  onLoad() {\r\n    let i = 0\r\n    setInterval(() => { i++ }, 100)\r\n  }\r\n})即使如小程序的 <swiper> 组件，在页面进入后台态时依然是会持续轮播的。正确的做法是， 在页面 onHide 的时候手动把定时器清理掉，有必要时再在 onShow 阶段恢复定时器 。坦白讲，区区一个定时器回调函数的执行，对于系统的影响应该是微不足道的，但不容忽视的是回调函数里的代码逻辑，譬如在定时器回调里持续 setData 大量数据，这就非常难受了...避免频发事件中的重度内存操作我们经常会遇到这样的需求：广告曝光、图片懒加载、导航栏吸顶等等，这些都需要我们在页面滚动事件触发时实时监听元素位置或更新视图。在了解小程序的双线程模型之后不难发现，页面滚动时 onPageScroll 被频发触发，会使逻辑层和视图层发生持续通信，若这时候再 “火上浇油” 调用 setData 传输大量数据，会导致内存使用率快速上升，使页面卡顿甚至 “假死”。所以，针对频发事件的监听，我们最好遵循以下原则：onPageScroll 事件回调使用节流；避免 CPU 密集型操作，譬如复杂的计算；避免调用 setData ，或减小 setData 的数据量；尽量使用 IntersectionObserver 来替代 SelectorQuery ，前者对性能影响更小；大图、长列表优化据 小程序官方文档 描述，大图片和长列表图片在 iOS 中会引起 WKWebView 的回收，导致小程序 Crash。对于大图片资源（譬如满屏的 gif 图）来说，我们只能尽可能对图片进行降质或裁剪，当然不使用是最好的。对于长列表，譬如瀑布流，这里提供一种思路：我们可以利用 IntersectionObserver 监听长列表内组件与视窗之间的相交状态，当组件距离视窗大于某个临界点时，销毁该组件释放内存空间，并用等尺寸的骨架图占坑；当距离小于临界点时，再取缓存数据重新加载该组件。然而无可避免地，当用户快速滚动长列表时，被销毁的组件可能来不及加载完，视觉上就会出现短暂的白屏。我们可以适当地调整销毁阈值，或者优化骨架图的样式来尽可能提升体验感。小程序官方提供了一个 长列表组件 ，可以通过 npm 包的方式引入，有兴趣的可以尝试。总结结合上述的种种方法论，京喜小程序首页进行全方位升级改造之后给出了答卷：1. Audits 审计工具的性能得分 86 ；2. 优化后的首屏渲染完成时间（FMP）：3. 优化前后的测速数据对比：然而，业务迭代在持续推进，多样化的用户场景徒增不减，性能优化将成为我们日常开发中挥之不去的原则和主题。本文以微信小程序开发中与性能相关的问题为出发点，基于小程序的底层框架原理，探究小程序性能体验提升的各种可能性，希望能为各位小程序开发者带来参考价值。参考User-centric Performance MetricsReduce JavaScript Payloads with Tree Shaking小程序开发指南小程序官方文档Taro 官方文档探究WebP一些事儿京喜首页（微信购物入口）跨端开发与优化实践欢迎关注凹凸实验室博客： aotu.io或者关注凹凸实验室公众号（AOTULabs），不定时推送文章："}
{"title": "微信小程序自定义navigationBar顶部导航栏，兼容适配所有机型（附完整案例） ... ", "author": "Rolan", "pub_time": "2020-3-27 00:37", "content": "本文首发自个人自有博客： 【FaxMiao个人博客】 ，一个关注Web前端开发技术、关注用户体验、记录前端点滴，坚持更多原创，为大家提供高质量技术博文！前言navigationBar相信大家都不陌生把？今天我们就来说说自定义navigationBar，把它改变成我们想要的样子（搜索框+胶囊、搜索框+返回按钮+胶囊等）。思路隐藏原生样式获取胶囊按钮、状态栏相关数据以供后续计算根据不同机型计算出该机型的导航栏高度，进行适配编写新的导航栏引用到页面正文一、隐藏原生的navigationBarwindow全局配置里有个参数：navigationStyle（导航栏样式），default=默认样式，custom=自定义样式。\"window\": {\r\n\t\"navigationStyle\": \"custom\"\r\n}\r\n复制代码让我们看看隐藏后的效果：可以看到原生的navigationBar已经消失了，剩下孤零零的胶囊按钮，胶囊按钮是无法隐藏的。二、准备工作1.获取胶囊按钮的布局位置信息我们用wx.getMenuButtonBoundingClientRect() 【官方文档】 获取胶囊按钮的布局位置信息，坐标信息以屏幕左上角为原点：const menuButtonInfo = wx.getMenuButtonBoundingClientRect();\r\n复制代码widthheighttoprightbottomleft宽度高度上边界坐标右边界坐标下边界坐标左边界坐标下面是官方给的示意图，方便大家理解几个坐标。2.获取系统信息用wx.getSystemInfoSync() 【官方文档】 获取系统信息，里面有个参数：statusBarHeight（状态栏高度），是我们后面计算整个导航栏的高度需要用到的。const systemInfo = wx.getSystemInfoSync();\r\n复制代码三、计算公式我们先要知道导航栏高度是怎么组成的， 计算公式： 导航栏高度 = 状态栏到胶囊的间距（胶囊距上距离-状态栏高度） * 2 + 胶囊高度 + 状态栏高度 。实例 【源码下载】自定义导航栏会应用到多个、甚至全部页面，所以封装成组件，方便调用；下面是我写的一个简单例子：app.jsApp({\r\n    onLaunch: function(options) {\r\n        const that = this;\r\n        // 获取系统信息\r\n        const systemInfo = wx.getSystemInfoSync();\r\n        // 胶囊按钮位置信息\r\n        const menuButtonInfo = wx.getMenuButtonBoundingClientRect();\r\n        // 导航栏高度 = 状态栏到胶囊的间距（胶囊距上距离-状态栏高度） * 2 + 胶囊高度 + 状态栏高度\r\n        that.globalData.navBarHeight = (menuButtonInfo.top - systemInfo.statusBarHeight) * 2 + menuButtonInfo.height + systemInfo.statusBarHeight;\r\n        that.globalData.menuRight = systemInfo.screenWidth - menuButtonInfo.right;\r\n        that.globalData.menuBotton = menuButtonInfo.top - systemInfo.statusBarHeight;\r\n        that.globalData.menuHeight = menuButtonInfo.height;\r\n    },\r\n    // 数据都是根据当前机型进行计算，这样的方式兼容大部分机器\r\n    globalData: {\r\n        navBarHeight: 0, // 导航栏高度\r\n        menuRight: 0, // 胶囊距右方间距（方保持左、右间距一致）\r\n        menuBotton: 0, // 胶囊距底部间距（保持底部间距一致）\r\n        menuHeight: 0, // 胶囊高度（自定义内容可与胶囊高度保证一致）\r\n    }\r\n})\r\n复制代码app.json{\r\n    \"pages\": [\r\n        \"pages/index/index\"\r\n    ],\r\n    \"window\": {\r\n        \"navigationStyle\": \"custom\"\r\n    },\r\n    \"sitemapLocation\": \"sitemap.json\"\r\n}\r\n复制代码下面为组件代码： /components/navigation-bar/navigation-bar.wxml<!-- 自定义顶部栏 -->\r\n<view class=\"nav-bar\" style=\"height:{{navBarHeight}}px;\">\r\n    <input class=\"search\" placeholder=\"输入关键词！\" style=\"height:{{menuHeight}}px; min-height:{{menuHeight}}px; line-height:{menuHeight}}px; left:{{menuRight}}px; bottom:{{menuBotton}}px;\"></input>\r\n</view>\r\n\r\n<!-- \r\n    内容区域：\r\n    自定义顶部栏用的fixed定位，会遮盖到下面内容，注意设置好间距\r\n-->\r\n<view class=\"content\" style=\"margin-top:{{navBarHeight}}px;\"></view>\r\n复制代码/components/navigation-bar/navigation-bar.json{\r\n  \"component\": true\r\n}\r\n复制代码/components/navigation-bar/navigation-bar.jsconst app = getApp()\r\nComponent({\r\n    properties: {\r\n        // defaultData（父页面传递的数据-就是引用组件的页面）\r\n        defaultData: {\r\n            type: Object,\r\n            value: {\r\n                title: \"我是默认标题\"\r\n            },\r\n            observer: function(newVal, oldVal) {}\r\n        }\r\n    },\r\n    data: {\r\n        navBarHeight: app.globalData.navBarHeight,\r\n        menuRight: app.globalData.menuRight,\r\n        menuBotton: app.globalData.menuBotton,\r\n        menuHeight: app.globalData.menuHeight,\r\n    },\r\n    attached: function() {},\r\n    methods: {}\r\n})\r\n复制代码/components/navigation-bar/navigation-bar.wxss.nav-bar{ position: fixed; width: 100%; top: 0; color: #fff; background: #000;}\r\n.nav-bar .search{ width: 60%; color: #333; font-size: 14px; background: #fff; position: absolute; border-radius: 50px; background: #ddd; padding-left: 14px;}\r\n复制代码以下是调用页面的代码，也就是引用组件的页面： /pages/index/index.wxml<navigation-bar default-data=\"{{defaultData}}\"></navigation-bar>\r\n复制代码/pages/index/index.json{\r\n    \"usingComponents\": {\r\n        \"navigation-bar\": \"/components/navigation-bar/navigation-bar\"\r\n    }\r\n}\r\n复制代码/pages/index/index.jsconst app = getApp();\r\nPage({\r\n    data: {\r\n        // 组件参数设置，传递到组件\r\n        defaultData: {\r\n            title: \"我的主页\", // 导航栏标题\r\n        }\r\n    },\r\n    onLoad() {\r\n        console.log(this.data.height)\r\n    }\r\n})\r\n复制代码效果图：好了，以上就是全部代码了，大家可以文中复制代码，也可以 【下载源码】，直接到开发者工具里运行，记得appid用自己的或者测试哦！下面附几张其它小程序的效果图，大家也可以尝试照着做：总结本文写了自定义navigationBar的一些基础性东西，里面涉及组件用法、参数传递、导航栏相关。由于测试环境有限，大家在使用时如果发现有什么问题，希望及时反馈，以供及时更新帮助更多的人！大家有什么疑问，欢迎评论区留言！"}
{"title": "小程序中使用Echart ", "author": "Rolan", "pub_time": "2020-3-16 00:22", "content": "最近有几个小程序用到了图表，把我一顿折腾。所以来讲一下使用图表时所遇到的问题。我们所用到的是 ECharts 的微信小程序版本 ;它提供了一个小程序原生的组件，然后我们只需要在相关页面引用改组件就好了。使用前准备先下载 ecomfe/echarts-for-weixin 中 ec-canvas 整个文件夹里面的文件引用：然后在你的页面中 的 json文件中 引用。当然你也可以作为全局组件写在app.json 中。{ \r\n  \"usingComponents\": {\r\n     \"ec-canvas\": \"../../components/ec-canvas/ec-canvas\"\r\n    }\r\n}\r\n复制代码注意：上面的 ec-canvas 引用组件名不能随意改变，因为在封装的组件 ec-canvas.js 中，需要找到 该节点 。使用我们要手动给 我们的图表设置宽高，不然页面只会显示空白。也就是给.container 设置宽高。<view class=\"container\">\r\n  <ec-canvas\r\n   id=\"mychart-dom-bar\" \r\n   canvas-id=\"mychart-bar\" \r\n   ec=\"{{ ec }}\">\r\n  </ec- canvas>\r\n</view>\r\n复制代码其中 ec 是一个我们在 我们页面 中定义的对象，它使得图表能够在页面加载后被初始化并设置。初始化图表的方法如下：function initChart(canvas, width, height, dpr) {\r\n  const chart = echarts.init(canvas, null, {\r\n    width: width,\r\n    height: height,\r\n    devicePixelRatio: dpr // 像素\r\n   });\r\n  canvas.setChart(chart);\r\n   // 图表数据初始化\r\n  var option = {\r\n       ...\r\n   };\r\n   chart.setOption(option);\r\n     return chart;\r\n }\r\n复制代码这对于所有 ECharts 图表都是通用的，用户只需要修改上面 option 的内容，即可改变图表。 option 的使用方法参见 ECharts 配置项文档 。对于不熟悉 ECharts 的用户，可以参见 [5 分钟上手 ECharts]( echarts.baidu.com/tutorial.ht… 分钟上手 ECharts) 教程。因为我们一般都是需要延迟加载的， 也就是获取数据后才加载图表的,所以我们不能直接使用,我们需要在获取数据重新设置 options 之后才能使用。代码入下:**.wxml 文件 **<view class=\"echart-map\">\r\n  <view class=\"echart-title\">全国疫情新趋势</view>\r\n  <ec-canvas \r\n    wx:if=\"{{hasGetOption}}\"\r\n    class=\"map-chart\"   \r\n    id=\"map-chart\" \r\n    canvas-id=\"map-chart\" \r\n    ec=\"{{ ec }}\">\r\n   </ec-canvas>\r\n</view>\r\n复制代码.js 文件// 页面中需要引入 ec-canvas 文件夹中的 echcrts.js\r\nimport * as echarts from '../../components/ec-canvas/echarts';  \r\npage({\r\n  data: {\r\n    hasGetOption: false,\r\n    ec: {\r\n      // 当我们设置lazyLoad 为true 的时候，我们需要手动初始化图表。\r\n      lazyLoad: true,\r\n    }\r\n  },\r\n  ready() {\r\n    // 在ready 的时候获取组件的实例。否则可能获取不到。\r\n    this.echartInstance = this.selectComponent('.map-chart');\r\n},\r\nsetOption () {\r\n  let option = {\r\n     title: {\r\n        // text: '全国疫情新增趋势'\r\n     },\r\n     tooltip: {\r\n       trigger: 'axis'\r\n     },\r\n     legend: {\r\n       data: [ '确诊']\r\n      },\r\n     grid: {\r\n       left: '3%',\r\n       right: '4%',\r\n       bottom: '3%',\r\n       containLabel: true\r\n     },\r\n     xAxis: {\r\n       type: 'category',\r\n       boundaryGap: false,\r\n       data: []\r\n     },\r\n     yAxis: {\r\n       type: 'value'\r\n     },\r\n     series: [{\r\n       name: '确诊',\r\n       type: 'line',\r\n       stack: '总量',\r\n       data: [120, 132, 101, 134, 90, 230, 210],\r\n       smooth: true\r\n      }\r\n      ]\r\n    }\r\n  },\r\ninitChart(canvas, width, height, dpr) {\r\n  const chart = echarts.init(canvas, null, {\r\n    width: width,\r\n    height: height,\r\n    devicePixelRatio: dpr // new\r\n  });\r\n   canvas.setChart(chart);\r\n   let option = this.getOption();\r\n   chart.setOption(option);\r\n   return chart;\r\n  },\r\ngetPageData() {\r\n   wx.request({\r\n      ...\r\n     success: (res) => {\r\n        // 获取到数据后再手动初始化\r\n      this.echartInstance.init(this.initChart);\r\n       this.setData({\r\n         hasGetOption: true,\r\n          ...\r\n        })\r\n      }\r\n    })\r\n  }\r\n})\r\n复制代码在之前的版本中会出现这么一个问题：因为最新基础库版本中 支持 Canvas 2d，这个可以提升渲染性能，解决非同层渲染问题。解决这个问题只需要在 ec-cnavas.js 的data 中将 isUseNewCanvas 设为true即可。在 Taro 中使用因为 Taro 中可以使用 微信中的原生组件，以及微信中的自定义组件。 所以使用方法同微信小程序类似。下载页面引用config = {\r\n  navigationBarTitleText: '首页',\r\n  usingComponents: {\r\n     \"ec-canvas\": \"../../components/ec-canvas/ec-canvas\"\r\n  }\r\n}\r\n复制代码使用：state = {\r\n  ec: {\r\n    lazyLoad: true,\r\n  }\r\n};\r\n// 获取组件实例。\r\nsetCanvasRef = node => this.canvasRef = node;\r\nrender () {\r\n  return (\r\n    <View className=\"line-chart\">\r\n       <ec-canvas \r\n         id=\"price-chart\" \r\n         canvas-id=\"price-chart\" \r\n         ref={this.setCanvasRef} \r\n         ec={ec} />\r\n   </View>)\r\n}\r\n复制代码然后在数据请求完后 再图表初始化。 init 是再组件中定义的this.canvasRef.init (this.initChart);   \r\n复制代码"}
